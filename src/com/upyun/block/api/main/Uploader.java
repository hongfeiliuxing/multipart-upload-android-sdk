/** * com.upyun.api * Upload.java */package com.upyun.block.api.main;import java.io.File;import java.io.FileNotFoundException;import java.io.IOException;import java.io.RandomAccessFile;import java.io.UnsupportedEncodingException;import java.text.DecimalFormat;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.TreeSet;import org.apache.commons.codec.digest.DigestUtils;import org.json.JSONArray;import org.json.JSONException;import org.json.JSONObject;import com.belladati.httpclientandroidlib.Header;import com.belladati.httpclientandroidlib.HttpEntity;import com.belladati.httpclientandroidlib.HttpResponse;import com.belladati.httpclientandroidlib.NameValuePair;import com.belladati.httpclientandroidlib.StatusLine;import com.belladati.httpclientandroidlib.client.ClientProtocolException;import com.belladati.httpclientandroidlib.client.HttpClient;import com.belladati.httpclientandroidlib.client.entity.UrlEncodedFormEntity;import com.belladati.httpclientandroidlib.client.methods.HttpPost;import com.belladati.httpclientandroidlib.entity.ContentType;import com.belladati.httpclientandroidlib.entity.mime.HttpMultipartMode;import com.belladati.httpclientandroidlib.entity.mime.MultipartEntityBuilder;import com.belladati.httpclientandroidlib.entity.mime.content.ByteArrayBody;import com.belladati.httpclientandroidlib.impl.client.HttpClientBuilder;import com.belladati.httpclientandroidlib.message.BasicNameValuePair;import com.belladati.httpclientandroidlib.util.EntityUtils;import com.upyun.block.api.exception.UpYunException;import com.upyun.block.api.statics.Constant;import com.upyun.block.api.statics.Params;import com.upyun.block.api.utils.UpYunUtils;/** * 表单分块上传SDK *  * @author wangxiaolong *  */public class Uploader {	 private static final String HOST = "http://m0.api.upyun.com/";	 private static final String boundary = "-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";	 	 private static DecimalFormat df = new DecimalFormat("0.00");		/**	 * 初始化上传	 * 	 * @param policy    文件操作列表（save_token,expiration必须，其他可选参数参见http://docs.upyun.com/api/form_api/#Policy内容详解）	 * @param signature	 * @param bucket	 * @return	 * @throws UpYunException	 */	public static JSONObject initialUpload(String policy, String signature, String bucket) throws UpYunException{		//参数验证		if (policy == null || "".equals(policy)) {			throw new UpYunException("policy can not be empty.");		}		if (signature == null || "".equals(signature)) {			throw new UpYunException("signature can not be empty.");		}		if (bucket == null || "".equals(bucket)) {			throw new UpYunException("bucket can not be empty.");		}				//build entity & send request		List<NameValuePair> pairList = new ArrayList<NameValuePair>();		NameValuePair param1 = new BasicNameValuePair(Params.POLICY, policy);		NameValuePair param2 = new BasicNameValuePair(Params.SIGNATURE, signature);		pairList.add(param1);		pairList.add(param2);		try {			HttpEntity entity = new UrlEncodedFormEntity(pairList);			return doRequest(entity, getUrl(bucket));		} catch (UnsupportedEncodingException e) {			throw new UpYunException(e.getMessage());		}	}	/**	 * 上传分块	 * 	 * @param tokenSecret    由初始化请求中服务器端返回的	 * @param bucket	 * @param saveToken		 在“初始化请求”时得到的该文件的唯一标识。注意：只要保存了该token，那么在有效期内，就能定位到该文件，从而进行续传，否则就要重新发起初始化请求来获得新的token	 * @param localFilePath  本地文件路径	 * @param blockSize      分块大小。注意：在该文件上传成功以前，不要修改设定好的blockSize,否则将上传数据会出问题	 * @param expiration	 * @param blockIndex     列表中记录未上传的index,默认未上传index列表[0...(totalBlockNum-1)]	 * @return	 * @throws UpYunException	 */	public static JSONObject uploadBlocks(String tokenSecret, String bucket, String saveToken, String localFilePath, int blockSize, long expiration, TreeSet<Integer> blockIndex) throws UpYunException{		//参数验证		if (tokenSecret == null || "".equals(tokenSecret)) {			throw new UpYunException("tokenSecret can not be empty.");		}		if (bucket == null || "".equals(bucket)) {			throw new UpYunException("bucket can not be empty.");		}		if (localFilePath == null || "".equals(localFilePath)) {			throw new UpYunException("localFilePath can not be empty.");		}		File localFile = new File(localFilePath);		if (!localFile.exists()) {			throw new UpYunException("can not find file in " + localFilePath + ".");		}		if (localFile.length() > Integer.MAX_VALUE) {			throw new UpYunException("this file is too large.Max is Integer.MAX_VALUE");		}		if (blockSize < Constant.MIN_BLOCK_SIZE) {			throw new UpYunException("BlockSize should be at least "+Constant.MIN_BLOCK_SIZE+".");		}				int totalBlockNum = UpYunUtils.getBlockNum(localFile, blockSize);				if (blockIndex == null || blockIndex.size() == 0) {			blockIndex = new TreeSet<Integer>();			for(int i = 0 ; i < totalBlockNum ; i++){				blockIndex.add(i);			}		}		JSONObject result = null;		RandomAccessFile randomAccessFile = null;		try {			//open file			byte blockTmp[] = new byte[blockSize];			try {				randomAccessFile = new RandomAccessFile(localFile, "r");			} catch (FileNotFoundException e) {				throw new UpYunException(e.getMessage());			}						HashMap<String, Object> policyMap = new HashMap<String, Object>();			policyMap.put(Params.SAVE_TOKEN, saveToken);			policyMap.put(Params.EXPIRATION, expiration);			int readedBlocks = 0;			int readedSize = 0;			for (Integer index : blockIndex) {				for (int i = 0; i < (index - readedBlocks); i++) {//这种写法非常有问题					randomAccessFile.read(blockTmp, 0, blockSize); //一次性把一个块读到内存，android能受的了吗？				}				readedSize = randomAccessFile.read(blockTmp, 0, blockSize);				if(readedSize == -1){					throw new IndexOutOfBoundsException("文件读取越界");				}				readedBlocks = index + 1;				policyMap.put(Params.BLOCK_INDEX, index);								JSONObject resultTmp = null;				if(index == (totalBlockNum - 1)){  //最后一个block不一定是满的，特殊处理一下					byte[] lastBlock = new byte[readedSize];					System.arraycopy(blockTmp, 0, lastBlock, 0, readedSize);					policyMap.put(Params.BLOCK_MD5, UpYunUtils.md5Hex(lastBlock));					resultTmp = uploadBlockProxy(policyMap, lastBlock, bucket, tokenSecret);				}else{					policyMap.put(Params.BLOCK_MD5, UpYunUtils.md5Hex(blockTmp));					resultTmp = uploadBlockProxy(policyMap, blockTmp, bucket, tokenSecret);				}								int code = resultTmp.getInt(Params.CODE);				if (code == 200) {					String progress = getProgress(resultTmp.getJSONArray(Params.STATUS));//					resultTmp.append("progress", progress);					result = resultTmp;				}else{					return resultTmp;				}			}		} catch(Exception e){			throw new UpYunException(e.getMessage());		}finally {			if (randomAccessFile != null) {				try {					randomAccessFile.close();				} catch (IOException e) {					e.printStackTrace();				}			}		}		return result;	}		/**	 * 获取请求url	 * 	 * @param bucket	 * @return	 */	private static String getUrl(String bucket){		return HOST + bucket + "/";	}		/**	 * 获取上传进度	 * 	 * 根据分块上传的返回结果中的'status'参数计算得到	 */	private static String getProgress(JSONArray array){		int length = array.length();		int count = 0;		try {		for(int i = 0 ; i<length ; i++){			int a = array.getInt(i);			if(a == 1)				count++;		}		}catch(Exception e){			e.printStackTrace();		}		double result = (double)count/length;		return df.format(result);	}	/**	 * 合并分块请求（分块全部上传成功后请求）	 * 	 * @param policy     文件操作列表（save_token,expiration必须，其他可选参数参见http://docs.upyun.com/api/form_api/#Policy内容详解）	 * @param signature	 * @param bucket	 * @param returnUrl  客户端同步回调URL	 * @param notifyUrl  异步通知URL	 * @return	 * @throws UpYunException	 */	public static JSONObject uploadFinish(String policy, String signature, String bucket) throws UpYunException{		//参数验证		if (policy == null || "".equals(policy)) {			throw new UpYunException("policy can not be empty.");		}		if (signature == null || "".equals(signature)) {			throw new UpYunException("signature can not be empty.");		}		if (bucket == null || "".equals(bucket)) {			throw new UpYunException("bucket can not be empty.");		}				//build entity & send request		List<NameValuePair> paramList = new ArrayList<NameValuePair>();		NameValuePair param1 = new BasicNameValuePair(Params.POLICY, policy);		NameValuePair param2 = new BasicNameValuePair(Params.SIGNATURE, signature);		paramList.add(param1);		paramList.add(param2);		try {			HttpEntity entity = new UrlEncodedFormEntity(paramList);			return doRequest(entity, getUrl(bucket));		} catch (UnsupportedEncodingException e) {			throw new UpYunException(e.getMessage());		}	}	/**	 * 发送请求	 * 	 * @param entity	 * @param url	 * @return	 * @throws UpYunException	 */	private static JSONObject doRequest(HttpEntity entity, String url) throws UpYunException {		JSONObject jsonObj = null;		try {			HttpClient httpclient = HttpClientBuilder.create().build();			HttpPost httpPost = new HttpPost(url);			httpPost.setEntity(entity);			HttpResponse response = httpclient.execute(httpPost);						StatusLine statusLine = response.getStatusLine();			String responseJson = EntityUtils.toString(response.getEntity());						jsonObj = new JSONObject(responseJson);			jsonObj.put("code", statusLine.getStatusCode());			if(jsonObj.getString("error_code") != null) {				Header[] headers = response.getHeaders("X-Request-Id");				jsonObj.put("X-Request-Id", headers[0].getValue());			}		} catch (JSONException e) {			throw new UpYunException(e.getMessage());		} catch (Exception e) {			throw new UpYunException(e.getMessage());		}		return jsonObj;	}	private static JSONObject uploadBlockProxy(HashMap<String, Object> map,byte[] block, String bucket,String secretkey) throws UpYunException{		String policy = UpYunUtils.getPolicy(map);		String signature = UpYunUtils.getSignature(map, secretkey);		MultipartEntityBuilder entityBuilder = MultipartEntityBuilder.create();		entityBuilder.setBoundary(boundary);		entityBuilder.setMode(HttpMultipartMode.BROWSER_COMPATIBLE);		entityBuilder.addPart("file", new ByteArrayBody(block,ContentType.APPLICATION_OCTET_STREAM,"block"));		entityBuilder.addTextBody("policy", policy);		entityBuilder.addTextBody("signature", signature);		HttpEntity entity = entityBuilder.build();		return doRequest(entity, getUrl(bucket));	}}