/** * com.upyun.api * Upload.java */package com.upyun.block.api.main;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.io.RandomAccessFile;import java.io.UnsupportedEncodingException;import java.text.DecimalFormat;import java.util.ArrayList;import java.util.Calendar;import java.util.HashMap;import java.util.List;import java.util.TreeSet;import org.apache.commons.codec.digest.DigestUtils;import org.json.JSONArray;import org.json.JSONException;import org.json.JSONObject;import com.belladati.httpclientandroidlib.Header;import com.belladati.httpclientandroidlib.HttpEntity;import com.belladati.httpclientandroidlib.HttpResponse;import com.belladati.httpclientandroidlib.NameValuePair;import com.belladati.httpclientandroidlib.StatusLine;import com.belladati.httpclientandroidlib.client.ClientProtocolException;import com.belladati.httpclientandroidlib.client.HttpClient;import com.belladati.httpclientandroidlib.client.entity.UrlEncodedFormEntity;import com.belladati.httpclientandroidlib.client.methods.HttpPost;import com.belladati.httpclientandroidlib.entity.ContentType;import com.belladati.httpclientandroidlib.entity.mime.HttpMultipartMode;import com.belladati.httpclientandroidlib.entity.mime.MultipartEntityBuilder;import com.belladati.httpclientandroidlib.entity.mime.content.ByteArrayBody;import com.belladati.httpclientandroidlib.impl.client.HttpClientBuilder;import com.belladati.httpclientandroidlib.message.BasicNameValuePair;import com.belladati.httpclientandroidlib.util.EntityUtils;import com.upyun.block.api.exception.UpYunException;import com.upyun.block.api.statics.Constant;import com.upyun.block.api.statics.Params;import com.upyun.block.api.utils.UpYunUtils;/** * 表单分块上传SDK *  * @author wangxiaolong *  */public class Uploader {	private static final String HOST = "http://m0.api.upyun.com/";	private static final String boundary = "-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";	private static long expiration = Calendar.getInstance().getTimeInMillis() + 60;	private static int blockSize = 100 * 1024; // 单位：byte	private static DecimalFormat df = new DecimalFormat("0.00");	public static JSONObject upload(String bucket, String formApiSecret, String localFilePath,			String savePath) throws UpYunException {		try {			// ==========初始化上传========== //这里需要根据save_token和token_secret判断是否需要初始化			File localFile = new File(localFilePath);			HashMap<String, Object> paramsMap = new HashMap<String, Object>();			// 必须参数			paramsMap.put(Params.PATH, savePath);			paramsMap.put(Params.EXPIRATION, expiration);			paramsMap.put(Params.BLOCK_NUM, UpYunUtils.getBlockNum(localFile, blockSize));			paramsMap.put(Params.FILE_SIZE, localFile.length());			paramsMap.put(Params.FILE_MD5, UpYunUtils.md5Hex(new FileInputStream(localFile)));			// 计算policy			String policyForInitial = UpYunUtils.getPolicy(paramsMap);			// 计算签名			String signatureForInitial = UpYunUtils.getSignature(paramsMap, formApiSecret);			// 初始化上传			JSONObject initialResult = Uploader.initialUpload(policyForInitial,					signatureForInitial, bucket);						if (initialResult.has("error_code")){				/* 出错时返回：				 * {"X-Request-Id":"11d88831c76213d9082457e55b8ff478","message":"Bucket NotFound.","error_code":40401,"code":404}				 * "X-Request-Id"说明：出现错误时，将该字段值提供给又拍云，可以用来排插错误				 */				return initialResult;			}			String saveToken = initialResult.optString(Params.SAVE_TOKEN);			String tokenSecret = initialResult.optString(Params.TOKEN_SECRET);						// ==========上传分块==========			JSONObject uploadResult = Uploader.uploadBlocks(tokenSecret, bucket, saveToken,					localFilePath, blockSize, expiration, null);			if (uploadResult.getInt("code") == 200) {				// ==========合并分块请求==========				HashMap<String, Object> paramsMapFinish = new HashMap<String, Object>();				paramsMapFinish.put(Params.EXPIRATION, expiration);				paramsMapFinish.put(Params.SAVE_TOKEN, saveToken);				String policyForFinish = UpYunUtils.getPolicy(paramsMapFinish);				String signature = UpYunUtils.getSignature(paramsMapFinish, tokenSecret);				JSONObject result = Uploader.uploadFinish(policyForFinish, signature, bucket);				return result;			} else {				return uploadResult;			}		} catch (Exception e) {			e.printStackTrace();		}		return null;	}	/**	 * 初始化上传	 * 	 * @param policy	 *            文件操作列表（save_token,expiration必须，其他可选参数参见http://docs.upyun.com/	 *            api/form_api/#Policy内容详解）	 * @param signature	 * @param bucket	 * @return	 * @throws UpYunException	 */	public static JSONObject initialUpload(String policy, String signature, String bucket)			throws UpYunException {		// 参数验证		if (policy == null || "".equals(policy)) {			throw new UpYunException("policy can not be empty.");		}		if (signature == null || "".equals(signature)) {			throw new UpYunException("signature can not be empty.");		}		if (bucket == null || "".equals(bucket)) {			throw new UpYunException("bucket can not be empty.");		}		// build entity & send request		List<NameValuePair> pairList = new ArrayList<NameValuePair>();		NameValuePair param1 = new BasicNameValuePair(Params.POLICY, policy);		NameValuePair param2 = new BasicNameValuePair(Params.SIGNATURE, signature);		pairList.add(param1);		pairList.add(param2);		try {			HttpEntity entity = new UrlEncodedFormEntity(pairList);			return doRequest(entity, getUrl(bucket));		} catch (UnsupportedEncodingException e) {			throw new UpYunException(e.getMessage());		}	}	/**	 * 上传分块	 * 	 * @param tokenSecret	 *            由「初始化请求」中服务器端返回	 * @param bucket	 * @param saveToken	 *            在「初始化请求」时得到的该文件的唯一标识。注意：只要保存了该token，那么在有效期内，就能定位到该文件，从而进行续传，	 *            否则就要重新发起初始化请求来获得新的token	 * @param localFilePath	 *            本地文件路径	 * @param blockSize	 *            分块大小。注意：在该文件上传成功以前，不要修改设定好的blockSize,否则将上传数据会出问题	 * @param expiration	 * @param blockIndex	 *            列表中记录未上传的index,默认未上传index列表[0...(totalBlockNum-1)]	 * @return	 * @throws UpYunException	 */	public static JSONObject uploadBlocks(String tokenSecret, String bucket, String saveToken,			String localFilePath, int blockSize, long expiration, TreeSet<Integer> blockIndex)			throws UpYunException {		// 参数验证		if (tokenSecret == null || "".equals(tokenSecret)) {			throw new UpYunException("tokenSecret can not be empty.");		}		if (bucket == null || "".equals(bucket)) {			throw new UpYunException("bucket can not be empty.");		}		if (localFilePath == null || "".equals(localFilePath)) {			throw new UpYunException("localFilePath can not be empty.");		}		File localFile = new File(localFilePath);		if (!localFile.exists()) {			throw new UpYunException("can not find file in " + localFilePath + ".");		}		if (localFile.length() > Integer.MAX_VALUE) {			throw new UpYunException("this file is too large.Max is Integer.MAX_VALUE");		}		if (blockSize < Constant.MIN_BLOCK_SIZE) {			throw new UpYunException("BlockSize should be at least " + Constant.MIN_BLOCK_SIZE					+ ".");		}		int totalBlockNum = UpYunUtils.getBlockNum(localFile, blockSize);		if (blockIndex == null || blockIndex.size() == 0) {			blockIndex = new TreeSet<Integer>();			for (int i = 0; i < totalBlockNum; i++) {				blockIndex.add(i);			}		}		JSONObject result = null;		RandomAccessFile randomAccessFile = null;		try {			// open file			byte blockTmp[] = new byte[blockSize];			try {				randomAccessFile = new RandomAccessFile(localFile, "r");			} catch (FileNotFoundException e) {				throw new UpYunException(e.getMessage());			}			HashMap<String, Object> policyMap = new HashMap<String, Object>();			policyMap.put(Params.SAVE_TOKEN, saveToken);			policyMap.put(Params.EXPIRATION, expiration);			int readedBlocks = 0;			int readedSize = 0;			for (Integer index : blockIndex) {				for (int i = 0; i < (index - readedBlocks); i++) {// 这种写法非常有问题					randomAccessFile.read(blockTmp, 0, blockSize); // 一次性把一个块读到内存，android能受的了吗？				}				readedSize = randomAccessFile.read(blockTmp, 0, blockSize);				if (readedSize == -1) {					throw new IndexOutOfBoundsException("文件读取越界");				}				readedBlocks = index + 1;				policyMap.put(Params.BLOCK_INDEX, index);				JSONObject resultTmp = null;				if (index == (totalBlockNum - 1)) { // 最后一个block不一定是满的，特殊处理一下					byte[] lastBlock = new byte[readedSize];					System.arraycopy(blockTmp, 0, lastBlock, 0, readedSize);					policyMap.put(Params.BLOCK_MD5, UpYunUtils.md5Hex(lastBlock));					resultTmp = uploadBlockProxy(policyMap, lastBlock, bucket, tokenSecret);				} else {					policyMap.put(Params.BLOCK_MD5, UpYunUtils.md5Hex(blockTmp));					resultTmp = uploadBlockProxy(policyMap, blockTmp, bucket, tokenSecret);				}				int code = resultTmp.getInt(Params.CODE);				if (code == 200) {					String progress = getProgress(resultTmp.getJSONArray(Params.STATUS));					resultTmp.put("progress", progress);					result = resultTmp;				} else {					return resultTmp;				}			}		} catch (Exception e) {			throw new UpYunException(e.getMessage());		} finally {			if (randomAccessFile != null) {				try {					randomAccessFile.close();				} catch (IOException e) {					e.printStackTrace();				}			}		}		return result;	}	/**	 * 获取请求url	 * 	 * @param bucket	 * @return	 */	private static String getUrl(String bucket) {		return HOST + bucket + "/";	}	/**	 * 获取上传进度	 * 	 * 根据分块上传的返回结果中的'status'参数计算得到	 */	private static String getProgress(JSONArray array) {		int length = array.length();		int count = 0;		try {			for (int i = 0; i < length; i++) {				int a = array.getInt(i);				if (a == 1)					count++;			}		} catch (Exception e) {			e.printStackTrace();		}		double result = (double) count / length;		return df.format(result);	}	/**	 * 合并分块请求（分块全部上传成功后请求服务端合并分块）	 * 	 * @param policy	 *            文件操作列表（save_token,expiration必须，其他可选参数参见http://docs.upyun.com/	 *            api/form_api/#Policy内容详解）	 * @param signature	 * @param bucket	 * @param returnUrl	 *            客户端同步回调URL	 * @param notifyUrl	 *            异步通知URL	 * @return	 * @throws UpYunException	 */	public static JSONObject uploadFinish(String policy, String signature, String bucket)			throws UpYunException {		// 参数验证		if (policy == null || "".equals(policy)) {			throw new UpYunException("policy can not be empty.");		}		if (signature == null || "".equals(signature)) {			throw new UpYunException("signature can not be empty.");		}		if (bucket == null || "".equals(bucket)) {			throw new UpYunException("bucket can not be empty.");		}		// build entity & send request		List<NameValuePair> paramList = new ArrayList<NameValuePair>();		NameValuePair param1 = new BasicNameValuePair(Params.POLICY, policy);		NameValuePair param2 = new BasicNameValuePair(Params.SIGNATURE, signature);		paramList.add(param1);		paramList.add(param2);		try {			HttpEntity entity = new UrlEncodedFormEntity(paramList);			return doRequest(entity, getUrl(bucket));		} catch (UnsupportedEncodingException e) {			throw new UpYunException(e.getMessage());		}	}	private static JSONObject uploadBlockProxy(HashMap<String, Object> map, byte[] block,			String bucket, String secretkey) throws UpYunException {		String policy = UpYunUtils.getPolicy(map);		String signature = UpYunUtils.getSignature(map, secretkey);		MultipartEntityBuilder entityBuilder = MultipartEntityBuilder.create();		entityBuilder.setBoundary(boundary);		entityBuilder.setMode(HttpMultipartMode.BROWSER_COMPATIBLE);		entityBuilder.addPart("file", new ByteArrayBody(block,				ContentType.APPLICATION_OCTET_STREAM, "block"));		entityBuilder.addTextBody("policy", policy);		entityBuilder.addTextBody("signature", signature);		HttpEntity entity = entityBuilder.build();		return doRequest(entity, getUrl(bucket));	}	/**	 * 发送请求	 * 	 * @param entity	 * @param url	 * @return	 * @throws UpYunException	 */	private static JSONObject doRequest(HttpEntity entity, String url) throws UpYunException {		JSONObject jsonObj = null;		try {			HttpClient httpclient = HttpClientBuilder.create().build();			HttpPost httpPost = new HttpPost(url);			httpPost.setEntity(entity);			HttpResponse response = httpclient.execute(httpPost);			StatusLine statusLine = response.getStatusLine();			String responseJson = EntityUtils.toString(response.getEntity());			jsonObj = new JSONObject(responseJson);			jsonObj.put("code", statusLine.getStatusCode());			if (jsonObj.has("error_code")) {				Header[] headers = response.getHeaders("X-Request-Id");				if (headers!=null && headers.length == 1)					jsonObj.put("X-Request-Id", headers[0].getValue());			}		} catch (Exception e) {			throw new UpYunException(e.getMessage());		}		return jsonObj;	}}